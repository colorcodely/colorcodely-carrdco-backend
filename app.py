import os
from datetime import datetime

from flask import Flask, request, jsonify
from twilio.rest import Client

from sheets import (
    add_subscriber,
    get_all_subscribers,
    save_daily_transcription,
    get_latest_transcription,
)
from sms import send_sms
from emailer import send_email

app = Flask(__name__)

# Environment variables
TWILIO_SID = os.getenv("TWILIO_ACCOUNT_SID")
TWILIO_AUTH = os.getenv("TWILIO_AUTH_TOKEN")
TWILIO_FROM = os.getenv("TWILIO_FROM_NUMBER")  # +12568011212

# The Huntsville Municipal Court color-code recording line
HUNTSVILLE_COLOR_LINE = "+12564277808"

# The public URL of your backend (for Twilio callbacks)
BASE_URL = os.getenv("APP_BASE_URL")

twilio_client = Client(TWILIO_SID, TWILIO_AUTH) if (TWILIO_SID and TWILIO_AUTH) else None


@app.route("/health", methods=["GET"])
def health():
    """Simple health check."""
    return jsonify({"status": "ok"})


def _get_request_data():
    """
    Support both Carrd POST styles:
      - form-encoded (default)
      - JSON (if enabled or sent manually)
    """
    data = request.get_json(silent=True)
    if data is None:
        data = request.form
    return data


@app.route("/submit", methods=["POST"])
def submit():
    """
    New subscriber signup:
        - full_name
        - email
        - cell_number
        - testing_center

    Steps:
        1. Save subscriber to Google Sheets
        2. Get today's transcription (if any)
        3. Send a welcome SMS + email (including today's announcement)
    """
    try:
        data = _get_request_data()

        full_name = data.get("full_name")
        email = data.get("email")
        cell_number = data.get("cell_number")
        testing_center = data.get("testing_center")

        if not (full_name and email and cell_number and testing_center):
            return jsonify({"status": "error", "message": "Missing required fields"}), 400

        # Save subscriber
        add_subscriber(full_name, email, cell_number, testing_center)

        # Get the latest daily transcription
        latest_date, latest_text = get_latest_transcription()
        today = datetime.utcnow().strftime("%Y-%m-%d")

        has_today_text = (latest_date == today and latest_text)

        # Prepare messages
        if has_today_text:
            email_subject = "Today's Color Code Announcement"
            email_body = (
                f"Hello {full_name},\n\n"
                f"Here is today's color code announcement for {testing_center}:\n\n"
                f"{latest_text}\n\n"
                "This message was automatically generated by ColorCodely."
            )
            sms_message = (
                f"ColorCodely - Today's color code for {testing_center}: "
                f"{latest_text}"
            )
        else:
            email_subject = "Welcome to ColorCodely"
            email_body = (
                f"Hello {full_name},\n\n"
                f"You are now subscribed to daily color code notifications for {testing_center}.\n"
                "You will begin receiving messages after the next daily announcement call.\n\n"
                "Thank you for joining ColorCodely!"
            )
            sms_message = (
                f"Welcome to ColorCodely! You are subscribed for {testing_center}. "
                f"Daily updates will begin after the next run."
            )

        # Send email
        try:
            send_email(email, email_subject, email_body)
        except Exception as e:
            print("Error sending email:", e)

        # Send SMS
        try:
            send_sms(cell_number, sms_message)
        except Exception as e:
            print("Error sending SMS:", e)

        return jsonify({"status": "success"}), 200

    except Exception as e:
        print("Error in /submit:", e)
        return jsonify({"status": "error", "message": str(e)}), 500


@app.route("/daily-call", methods=["POST"])
def daily_call():
    """
    This will be triggered daily via a Render Cron Job.
    It initiates a Twilio call to the Huntsville number and records it.
    Twilio will POST transcription/recording info to /twilio/recording-complete
    """
    if not twilio_client:
        return jsonify({"status": "error", "message": "Twilio not configured"}), 500

    if not BASE_URL:
        return jsonify({"status": "error", "message": "APP_BASE_URL not set"}), 500

    try:
        callback_url = f"{BASE_URL}/twilio/recording-complete"

        call = twilio_client.calls.create(
            to=HUNTSVILLE_COLOR_LINE,
            from_=TWILIO_FROM,
            record=True,
            recording_status_callback=callback_url,
            recording_status_callback_method="POST",
        )

        print("Daily call initiated. Call SID:", call.sid)
        return jsonify({"status": "started", "call_sid": call.sid}), 200

    except Exception as e:
        print("Error starting daily call:", e)
        return jsonify({"status": "error", "message": str(e)}), 500


@app.route("/twilio/recording-complete", methods=["POST"])
def twilio_recording_complete():
    """
    Twilio sends recording/transcription info to this URL.

    If "TranscriptionText" is available (Twilio automatic transcription),
    we save it. Otherwise we save a placeholder.

    After saving:
      - We pull all subscribers
      - Send each one the text and email version of today's announcement
    """
    try:
        form = request.form
        print("Twilio callback received:", dict(form))

        transcription_text = form.get("TranscriptionText")
        recording_url = form.get("RecordingUrl")

        if not transcription_text:
            transcription_text = (
                "Daily announcement recorded. Transcription unavailable "
                "(your Twilio transcription settings may need to be enabled)."
            )

        today = datetime.utcnow().strftime("%Y-%m-%d")

        # Save transcription to Google Sheets
        save_daily_transcription(transcription_text, today)

        # Notify subscribers
        subscribers = get_all_subscribers()

        for sub in subscribers:
            full_name = sub.get("full_name", "Subscriber")
            email = sub.get("email")
            phone = sub.get("cell_number")
            testing_center = sub.get("testing_center", "your testing center")

            email_subject = "Today's Color Code Announcement"
            email_body = (
                f"Hello {full_name},\n\n"
                f"Here is today's color code announcement for {testing_center}:\n\n"
                f"{transcription_text}\n\n"
                f"(Recording URL: {recording_url or 'N/A'})\n\n"
                "This message was automatically generated by ColorCodely."
            )
            sms_body = (
                f"ColorCodely - Today's color code for {testing_center}: "
                f"{transcription_text}"
            )

            if email:
                try:
                    send_email(email, email_subject, email_body)
                except Exception as e:
                    print(f"Error sending email to {email}: {e}")

            if phone:
                try:
                    send_sms(phone, sms_body)
                except Exception as e:
                    print(f"Error sending SMS to {phone}: {e}")

        return jsonify({"status": "ok"}), 200

    except Exception as e:
        print("Error handling Twilio callback:", e)
        return jsonify({"status": "error", "message": str(e)}), 500


# Debug/local mode (not used on Render)
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)
